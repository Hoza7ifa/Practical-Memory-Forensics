# Ch5 -  Malware Detection and Analysis with Windows Memory Forensics

---

# Detailed Summary of Chapter 5: Malware Detection and Analysis with Windows Memory Forensics

This chapter from *Practical Memory Forensics* by Svetlana Ostrovskaya focuses on detecting and analyzing malicious activity in Windows memory dumps, crucial for investigating cyber incidents involving malware or attacker tools. It covers identifying rogue processes, analyzing command-line arguments, examining network connections, detecting code injections, finding persistence mechanisms, and creating timelines. The chapter emphasizes memory forensics due to modern malware’s minimal disk footprint and stealth techniques like PowerShell and batch scripts. Below is a comprehensive summary of the theoretical concepts, tools, commands, and practical steps, designed to be a complete reference for digital forensics investigators without reading the original chapter. Key notes and sensitive considerations are included to guide investigations.

---

- part 1
    
    ## Importance of Malware Detection in Memory Forensics
    
    - **Purpose**: Memory forensics is critical for detecting malicious activity on a victim’s computer, identifying rogue processes, network connections, code injections, and persistence mechanisms that leave minimal disk traces.
    - **Forensic Value**: Memory captures volatile data unavailable in post-mortem disk analysis, such as:
        - Running malicious processes (e.g., masqueraded as system processes).
        - Network connections to Command and Control (C2) servers.
        - Injected code or scripts executed in memory.
        - Registry and event log data indicating persistence or system changes.
    - **Applications**: Essential for incident response, identifying initial access, data exfiltration, lateral movement, and attacker tools in scenarios like ransomware, phishing, or advanced persistent threats (APTs).
    - **Modern Malware Trends**: Malware (e.g., IcedID, Emotet, Trickbot) and attackers use fileless techniques, PowerShell, and batch scripts to evade detection, making memory analysis indispensable.
    
    ## Technical Requirements
    
    - **Minimal Setup**: A Windows system (host or virtual machine) with Python 3 and necessary dependencies (e.g., Perl, Dokany) for running tools like Volatility, TheSleuthKit, and oletools.
    
    ## Searching for Malicious Processes
    
    ### Theoretical Concepts
    
    - **Goal**: Identify rogue processes indicating malicious activity, such as malware or attacker tools.
    - **Markers of Malicious Processes**:
        - **Process Names**: Malware may mimic system processes (e.g., svhost.exe vs. legitimate svchost.exe) or use unusual names (e.g., UWkpjFjDzM.exe for Meterpreter).
        - **Parent-Child Relationships**: Atypical combinations (e.g., svhost.exe spawned by nwe.exe instead of services.exe for legitimate svchost.exe).
        - **Atypical Behavior**: Processes like cmd.exe or powershell.exe making network connections or spawning unexpected child processes.
        - **Locations and Arguments**: Executables in temporary or user directories (e.g., C:\Users\AppData\Local\Temp) or suspicious command-line arguments.
    - **System Processes**:
        - Legitimate system processes (e.g., svchost.exe) have predefined parents (e.g., services.exe), fixed instance counts, users (e.g., SYSTEM), start times, and disk locations (e.g., C:\Windows\System32).
        - Deviations (e.g., wrong parent, location, or instance count) are suspicious.
    - **Dual-Use Tools**: Utilities like whoami.exe, ipconfig.exe, netstat.exe, cmd.exe, powershell.exe, wscript.exe, cscript.exe, and rundll32.exe are used by both administrators and attackers for execution, discovery, or lateral movement.
    - **Malware Example**: IcedID drops svhost.exe in a temporary directory, executed as a child process, distributed via phishing emails and linked to ransomware (e.g., REvil, Conti, Egregor).
    
    ### Practical Steps and Tools
    
    - **Volatility Framework**:
        - **Description**: Open-source tool for memory dump analysis, used with plugins like pslist, pstree, and psscan (see Chapter 4 for installation: https://www.volatilityfoundation.org/26).
        - **Plugin: pslist**:
            - **Purpose**: Lists active processes, highlighting suspicious names or parent-child relationships.
            - **Command**: .\volatility_2.6_win64_standalone.exe -f D:\nwe.mem --profile=Win7SP1x64 pslist.
            - **Output**: Process name, PID, PPID, threads, handles, creation time (Figure 5.1). Example: svhost.exe (PID 1664) lacks ‘c’ in name, indicating IcedID malware.
            - **Note**: Use regular expressions to filter processes (e.g., host to identify svchost vs. svhost).
        - **Analysis Steps**:
            1. Run pslist to list active processes.
            2. Identify anomalies: misspelled names (e.g., svhost.exe), unusual PIDs, or non-standard parents (e.g., nwe.exe for svhost.exe).
            3. Cross-reference with known system process attributes (parent, location, user).
    - **Important Notes**:
        - Familiarize with system processes across Windows versions (e.g., XP, 7, 10) to spot anomalies.
        - Context matters: System processes vary slightly by OS version, affecting analysis.
    
    ## Analyzing Command-Line Arguments
    
    ### Theoretical Concepts
    
    - **Goal**: Extract command-line arguments to reveal executable locations, IP addresses, credentials, or scripts used by attackers.
    - **Forensic Value**: Arguments may include:
        - Malicious file paths (e.g., C:\Users\AppData\Local\Temp\svhost.exe).
        - C2 server IPs or hostnames.
        - Stolen credentials (e.g., PsExec arguments: psexec -u max -p <password>).
        - Base64-encoded scripts (common in fileless attacks).
    - **Fileless Attacks**: Attackers use tools like cmd.exe or powershell.exe to execute scripts without disk writes, complicating detection. Example: Phishing email with a malicious Word document macro spawns rundll32.exe or powershell.exe for ransomware deployment.
    - **Command History**: Stored in memory, capturing executed commands, critical for reconstructing attacker actions.
    
    ### Practical Steps and Tools
    
    - **Volatility Plugins**:
        - **cmdline**:
            - **Purpose**: Retrieves command-line arguments for processes.
            - **Command**: .\volatility_2.6_win64_standalone.exe -f D:\nwe.mem --profile=Win7SP1x64 cmdline -p <PID>.
            - **Output**: Executable path and arguments (Figure 5.10). Example: svhost.exe in C:\Users\AppData\Local\Temp (non-standard for svchost.exe) or PsExec with credentials and target hostname (Figure 5.11).
            - **Use Case**: Identifies malicious file locations or compromised credentials.
        - **cmdscan**:
            - **Purpose**: Extracts command history from cmd.exe.
            - **Command**: .\volatility_2.6_win64_standalone.exe -f D:\nwe.mem --profile=Win7SP1x64 cmdscan.
            - **Output**: Command history objects (Figure 5.12).
            - **Limitation**: Limited to default history size; use -M to adjust, but custom sizes are hard to detect.
        - **consoles**:
            - **Purpose**: Captures commands and their input/output buffers for cmd.exe, PowerShell, Python, or Perl shells.
            - **Command**: .\volatility_2.6_win64_standalone.exe -f D:\nwe.mem --profile=Win7SP1x64 consoles.
            - **Output**: Commands executed, results, and process details (e.g., conhost.exe with cmd.exe running updater.bat, spawning PowerShell; Figures 5.14, 5.15).
            - **Use Case**: Reveals script execution (e.g., PowerShell with -enc Base64-encoded command).
        - **yarascan**:
            - **Purpose**: Searches for malicious scripts using YARA rules (e.g., PowerShell with -nop, -w hidden, -enc).
            - **Command**: .\volatility_2.6_win64_standalone.exe -f D:\nwe.mem --profile=Win7SP1x64 yarascan -p <PID> -Y "<YARA_rule>".
            - **Output**: Matches for malicious scripts and associated processes (Figure 5.13).
            - **YARA Rule Example**: Search for PowerShell with suspicious options (https://yara.readthedocs.io/en/v4.1.0/gettingstarted.html).
    - **CyberChef**:
        - **Purpose**: Decodes Base64-encoded scripts (e.g., PowerShell commands).
        - **Steps**:
            1. Copy Base64 string from consoles or yarascan output.
            2. Paste into CyberChef (https://gchq.github.io/CyberChef/).
            3. Select Base64 decode recipe.
            4. Analyze output (e.g., WebClient object for network communication; Figure 5.16).
        - **Output**: Decoded script or PE file for further analysis.
    - **Analysis Steps**:
        1. Run cmdline to identify suspicious arguments (e.g., non-standard paths, credentials).
        2. Use cmdscan for cmd.exe command history.
        3. Use consoles for detailed command execution and results.
        4. Apply yarascan with YARA rules for script detection.
        5. Decode Base64 strings with CyberChef to reveal script functionality.
    - **Important Notes**:
        - Base64-encoded commands (e.g., -enc in PowerShell) are common in fileless attacks; always decode for analysis.
        - PsExec arguments reveal lateral movement and compromised credentials.
        - consoles provides input/output buffers, critical for understanding command impact.

---

- part 2
    
    ## Examining Network Connections
    
    ### Theoretical Concepts
    
    - **Goal**: Identify malicious network activity, such as C2 communications, data exfiltration, or remote access.
    - **Key Indicators**:
        - **Atypical Initiators**: Processes like explorer.exe, cmd.exe, or powershell.exe making unexpected connections.
        - **Suspicious IPs/Ports**: Foreign IPs linked to malicious files or non-standard ports used by attacker tools (e.g., Meterpreter on port 4444).
        - **Connection States**: TCP states (LISTENING, ESTABLISHED, CLOSED) indicate active or recent connections.
    - **Common Ports** (Figure 5.23):
        - 20-21: FTP (file/command transfer).
        - 22: SSH (secure data transfer).
        - 23: Telnet (unencrypted text).
        - 25, 110, 143: SMTP, POP3, IMAP (email).
        - 80, 443: HTTP, HTTPS (web).
        - 445: SMB (file sharing).
        - 3389: RDP (remote desktop).
    - **Attacker Tool Ports** (Figure 5.24):
        - 81, 9001: TOR.
        - 689: Nmap.
        - 1241: Nessus.
        - 3899, 4899: RAdmin.
        - 3790: Metasploit.
        - 4444: Meterpreter (reverse shell).
        - 50050: Cobalt Strike.
    - **Malware Example**: Meterpreter uses port 4444, identified by UWkpjFjDzM.exe (Figure 5.22).
    
    ### Practical Steps and Tools
    
    - **Volatility Plugin: netscan**:
        - **Purpose**: Lists active/recent connections and open sockets.
        - **Command**: .\volatility_2.6_win64_standalone.exe -f D:\nwe.mem --profile=Win7SP1x64 netscan.
        - **Output**: Protocol, local/foreign IP:port, PID, process name, creation time, TCP state (Figure 5.17). Example: cmd.exe (PID 2860) connects to 216.58.207.206 (Figure 5.18).
        - **Analysis Steps**:
            1. Run netscan to list connections.
            2. Identify atypical initiators (e.g., explorer.exe, cmd.exe).
            3. Check foreign IPs on VirusTotal (https://www.virustotal.com/gui/home/search).
            4. Examine ports for known attacker tools (e.g., 4444 for Meterpreter).
    - **VirusTotal**:
        - **Purpose**: Analyzes IP addresses, URLs, or file hashes for malicious associations.
        - **Steps**:
            1. Search IP (e.g., 216.58.207.206) on VirusTotal.
            2. Check “Communicating Files” in the RELATIONS tab (Figure 5.20).
            3. Review graphical view (requires account) for communication patterns.
        - **Output**: Indicates malicious files linked to the IP, even if the IP itself isn’t flagged (Figure 5.19).
    - **Important Notes**:
        - Legitimate processes (e.g., browsers, messengers) typically make network connections; others (e.g., explorer.exe) are suspicious unless for specific tasks (e.g., telemetry).
        - Non-standard ports or IPs linked to malicious files are red flags.
        - Meterpreter’s use of port 4444 is a strong indicator of a reverse shell.
    
    ## Detecting Injections in Process Memory
    
    ### Theoretical Concepts
    
    - **Goal**: Identify code injections (e.g., DLLs, executables, process hollowing, doppelgänging) used for defense evasion or privilege escalation.
    - **Types of Injections**:
        - **Remote DLL Injection**:
            - Mechanism: Malicious process gains SeDebugPrivilege, writes DLL path to target process’s address space, creates a thread to load the DLL, and clears traces.
            - Algorithm:
                1. Gain privileges and open target process handle.
                2. Write malicious DLL path to target process’s address space.
                3. Create thread to load DLL using Windows API.
                4. Clear DLL path from memory.
                5. Close handle.
            - Detection: DLL exists on disk, detectable via dllist or ldrmodules.
        - **Reflective DLL Injection**:
            - Mechanism: DLL is loaded from network into memory without disk writes, using a reflective loader.
            - Algorithm:
                1. Gain privileges and open target process handle.
                2. Allocate memory and write DLL.
                3. Create thread to invoke reflective loader.
                4. Close handle.
            - Examples: SDBbot, Netwalker ransomware, Metasploit, Cobalt Strike.
            - Detection: Uses PAGE_EXECUTE_READWRITE memory pages, detectable via malfind.
        - **Portable Executable (PE) Injection**:
            - Mechanism: Malicious code is written to target process’s memory and executed via a new thread.
            - Algorithm:
                1. Gain privileges and open target process handle.
                2. Allocate memory and write malicious code.
                3. Create thread to execute code.
                4. Close handle.
            - Detection: Uses PAGE_EXECUTE_READWRITE pages, detectable via malfind.
        - **Process Hollowing**:
            - Mechanism: Starts a legitimate process in SUSPEND state, overwrites its code with malicious code, and resumes execution.
            - Algorithm:
                1. Start legitimate process with suspended thread.
                2. Free legitimate code’s memory.
                3. Allocate new memory with EXECUTE_READWRITE.
                4. Copy malicious code to new memory.
                5. Set thread start address to malicious code.
                6. Resume thread.
            - Example: Trickbot injects into wermgr.exe.
            - Detection: Compare PEB and VAD structures for inconsistencies.
        - **Process Doppelgänging**:
            - Mechanism: Uses NTFS transactions to load malicious code without disk traces.
            - Algorithm:
                1. Create NTFS transaction and transacted file.
                2. Overwrite file with malicious code.
                3. Create memory section for transacted file.
                4. Roll back transaction (removes disk traces).
                5. Create process/thread objects, set thread to malicious code.
                6. Copy process parameters.
                7. Run doppelgänged process.
            - Example: Bazar Loader.
            - Detection: Check _EPROCESS.ImageFilePointer (NULL in Windows 10) or File_object write access (pre-Windows 10).
    - **Challenges**:
        - Injections like Meterpreter leave minimal footprints, running entirely in memory.
        - Attackers may remove executable headers or alter memory protections to evade malfind.
    
    ### Practical Steps and Tools
    
    - **Volatility Plugins**:
        - **dllist**:
            - **Purpose**: Lists loaded DLLs in a process’s LoadOrderList.
            - **Command**: .\volatility_2.6_win64_standalone.exe -f D:\dll.bin --profile=Win7SP1x64 dllist -p <PID>.
            - **Output**: DLL names, paths, and load order (Figure 5.25).
            - **Limitation**: Malicious DLLs unlinked from LoadOrderList are missed.
        - **ldrmodules**:
            - **Purpose**: Lists DLLs across LoadOrderList, MemoryOrderList, and InitOrderList, detecting unlinked DLLs.
            - **Command**: .\volatility_2.6_win64_standalone.exe -f D:\dll.bin --profile=Win7SP1x64 ldrmodules -p <PID>.
            - **Output**: Flags (InLoad, InMem, InInit) indicate unlinked DLLs (e.g., False in InLoad, True elsewhere; Figure 5.26).
            - **Note**: Executables show False in InInit due to different initialization.
        - **dlldump**:
            - **Purpose**: Extracts DLLs for analysis.
            - **Command**: .\volatility_2.6_win64_standalone.exe -f D:\dll.bin --profile=Win7SP1x64 dlldump -p 1072 -D D:\output.
            - **Output**: DLL files in specified directory (Figure 5.23).
        - **malfind**:
            - **Purpose**: Detects PAGE_EXECUTE_READWRITE regions for reflective DLLs, PE injections, or packed code.
            - **Command**: .\volatility_2.6_win64_standalone.exe -f D:\nwe.mem --profile=Win7SP1x64 malfind -p <PID> -D D:\output.
            - **Output**: Injected code sections, possibly with MZ headers (Figures 5.29, 5.30).
            - **Options**: -p <PID>, -n <regex>, -D <directory>.
            - **Limitation**: Misses injections with altered protections (e.g., read+execute only).
        - **psinfo**:
            - **Purpose**: Detects process hollowing by comparing PEB and VAD structures.
            - **Command**: .\volatility_2.6_win64_standalone.exe -f D:\nwe.mem --profile=Win7SP1x64 psinfo.
            - **Output**: Base address, process path, protection flags, command line (Figure 5.36). Hollowed processes lack VAD file mapping.
        - **volshell**:
            - **Purpose**: Checks _EPROCESS.ImageFilePointer for doppelgänging.
            - **Commands**:
                1. volshell -f D:\nwe.mem --profile=Win7SP1x64.
                2. ps() to list process offsets (Figure 5.37).
                3. dt('_EPROCESS', <offset>) to check ImageFilePointer (NULL indicates doppelgänging; Figures 5.38, 5.39).
        - **cobaltstrikescan**:
            - **Purpose**: Detects Cobalt Strike beacons using YARA rules.
            - **Setup**: Download from https://github.com/JPCERTCC/aa-tools/blob/master/cobaltstrikescan.py, place in plugins folder, run with --plugins=./plugins.
            - **Command**: .\volatility_2.6_win64_standalone.exe -f D:\nwe.mem --profile=Win7SP1x64 cobaltstrikescan --plugins=./plugins.
            - **Output**: Beacons in processes (e.g., Outlook.exe, rundll32.exe) with C2 IPs (Figure 5.35).
    - **Redline**:
        - **Purpose**: Manual memory analysis for injections with non-standard protections.
        - **Download**: https://www.fireeye.com/services/freeware/redline.html (requires form).
        - **Steps**:
            1. Load memory dump.
            2. View memory sections, protection flags, and contents (Figures 5.32, 5.33).
            3. Double-click sections for detailed analysis.
    - **VirusTotal**:
        - **Purpose**: Checks extracted DLLs or code for maliciousness.
        - **Steps**:
            1. Calculate file hash: Get-FileHash D:\output\*.dll in PowerShell (Figure 5.27).
            2. Search hash on VirusTotal (Figure 5.28).
    - **CFF Explorer**:
        - **Purpose**: Analyzes extracted code sections.
        - **Download**: https://ntcore.com/?page_id=388.
    - **Strings**:
        - **Purpose**: Extracts ASCII/Unicode strings from process memory for script analysis.
        - **Command**: strings D:\output\<PID>.dmp > D:\output\strings.txt.
        - **Steps**:
            1. Dump process memory: .\volatility_2.6_win64_standalone.exe -f D:\nwe.mem --profile=Win7SP1x64 memdump -p <PID> -D D:\output.
            2. Run Strings and search for keywords (e.g., powershell, base64; Figures 5.40, 5.41).
            3. Decode Base64 with CyberChef (Figure 5.42).
    - **oletools (olevba)**:
        - **Purpose**: Analyzes malicious MS Office macros (e.g., in GOT-7_HR.docm).
        - **Installation**: pip3.exe install -U oletools (requires Python 3).
        - **Command**: olevba D:\output\GOT-7_HR.docm.
        - **Output**: Macro details, obfuscated strings, code injection functionality (Figures 5.5, 5.6).
        - **Steps**:
            1. Extract document using handles, filescan, dumpfiles (see Chapter 4).
            2. Run olevba to detect malicious macros.
    - **Analysis Steps**:
        1. Use dllist and ldrmodules to detect remote DLL injections (check for unlinked DLLs or suspicious paths).
        2. Run malfind for reflective DLL or PE injections, dumping suspicious sections.
        3. Use psinfo for process hollowing, checking PEB vs. VAD inconsistencies.
        4. Use volshell for doppelgänging, verifying ImageFilePointer.
        5. Run cobaltstrikescan for Cobalt Strike beacons.
        6. Extract DLLs/code with dlldump or malfind -D, calculate hashes, and check on VirusTotal.
        7. Analyze extracted code with CFF Explorer or Strings (for scripts).
        8. For malicious documents, use olevba to analyze macros.
    - **Important Notes**:
        - Malicious DLLs in user/temporary directories (e.g., C:\Users\AppData\Local\Temp) are suspicious.
        - malfind may miss injections with altered protections; use Redline for manual analysis.
        - Legitimate software (e.g., antivirus) may use injections, requiring context to differentiate.
        - Community plugins (e.g., cobaltstrikescan) require proper setup in plugins folder.
        - Base64-encoded scripts in wscript.exe may indicate injected PE files (Figure 5.42).

---

- part 3
    
    ## Looking for Evidence of Persistence
    
    ### Theoretical Concepts
    
    - **Goal**: Identify mechanisms ensuring malware or attacker access persists across reboots or logons.
    - **Techniques** (MITRE ATT&CK references):
        - **Boot or Logon Autostart Execution**:
            - Modifies registry keys to run executables/scripts at startup.
            - Keys:
                - HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Winlogon
                - HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run
                - HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Run
                - HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce
                - HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon (T1547.004)
                - HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options (T1546.012)
                - HKCU\Environment\UserInitMprLogonScript (T1037.001)
        - **Create Account**:
            - Adds new local or domain accounts for persistent access, common in ransomware.
            - Stored in SAM registry (local users) or domain controller logs (domain users).
        - **Create or Modify System Process**:
            - Installs malicious services to run executables or scripts.
            - Example: Emotet, Trickbot create services in temporary folders.
            - Event ID 7045 in System.evtx logs service installation.
        - **Scheduled Task**:
            - Creates tasks to run malicious code at specified times.
            - Locations:
                - C:\Windows\System32\Tasks (XML task files).
                - Microsoft-Windows-TaskScheduler\%40perational.evtx (event ID 106).
                - SOFTWARE registry (task cache).
    - **Forensic Value**: Persistence mechanisms reveal attacker intent to maintain long-term access, critical for incident response.
    
    ### Practical Steps and Tools
    
    - **Volatility Plugins**:
        - **printkey**:
            - **Purpose**: Examines registry keys for autostart entries.
            - **Command**: .\volatility_2.6_win64_standalone.exe -f D:\nwe.mem --profile=Win7SP1x64 printkey -K "SOFTWARE\Microsoft\Windows\CurrentVersion\Run".
            - **Output**: Key values (e.g., Temp with temp.bat path; Figure 5.45).
        - **handles**:
            - **Purpose**: Lists registry keys accessed by a process.
            - **Command**: .\volatility_2.6_win64_standalone.exe -f D:\nwe.mem --profile=Win7SP1x64 handles -p <PID> -t Key.
            - **Output**: Registry keys used by the process (Figure 5.44).
            - **Note**: Absence of a key in handles doesn’t rule out its use; check registry directly.
        - **svcscan**:
            - **Purpose**: Lists running services, names, types, states, and binary paths.
            - **Command**: .\volatility_2.6_win64_standalone.exe -f D:\nwe.mem --profile=Win7SP1x64 svcscan.
            - **Output**: Service details, e.g., MuLiveUpdatingService in C:\Users\AppData\Local\Temp\MsRuntimeUpdates.exe (Figure 5.49).
        - **autoruns**:
            - **Purpose**: Collects service and registry key data for persistence.
            - **Setup**: Download from https://github.com/tomchop/volatility-autoruns/blob/master/autoruns.py, place in plugins folder.
            - **Command**: .\volatility_2.6_win64_standalone.exe -f D:\nwe.mem --profile=Win7SP1x64 autoruns --plugins=./plugins.
            - **Output**: Services and registry keys (Figure 5.50).
            - **Limitation**: Limited data scope; check repository for details.
        - **filescan** and **dumpfiles**:
            - **Purpose**: Exports event logs (security.evtx, System.evtx) or task files.
            - **Commands**:
                1. .\volatility_2.6_win64_standalone.exe -f D:\nwe.mem --profile=Win7SP1x64 filescan > D:\output\filescan.txt.
                2. Find log offset in filescan.txt (e.g., security.evtx).
                3. .\volatility_2.6_win64_standalone.exe -f D:\nwe.mem --profile=Win7SP1x64 dumpfiles -Q <offset> -D D:\output.
            - **Output**: Log files (rename with .evtx extension).
    - **Registry Explorer**:
        - **Purpose**: Analyzes registry hives (e.g., SAM, SOFTWARE) for user creation or autostart entries.
        - **Download**: https://ericzimmerman.github.io/#!index.md.
        - **Steps**:
            1. Export SAM or SOFTWARE using dumpregistry or MemProcFS (see Chapter 4).
            2. Load into Registry Explorer, check “Bookmarks > Users” for user creation dates (Figure 5.46).
            3. Check autostart keys (e.g., Run with temp.bat; Figure 5.43).
    - **RegRipper**:
        - **Purpose**: Parses SOFTWARE for scheduled task data.
        - **Commands**:
            1. Load SOFTWARE hive (e.g., M:\registry\hive_files\SOFTWARE via MemProcFS).
            2. Run rr.exe, select hive, output to D:\task_report.txt.
            3. Search for taskcache or tasks plugins (Figure 5.51).
        - **Output**: Task paths, creation times, IDs (Figure 5.52).
    - **Event Viewer**:
        - **Purpose**: Analyzes security.evtx (user creation, events 4720, 4722) or System.evtx (service installation, event 7045).
        - **Steps**:
            1. Open exported .evtx file in Windows Event Viewer.
            2. Filter by event IDs (e.g., 4720 for user creation, 7045 for services; Figures 5.47, 5.48).
        - **Output**: User creation details (e.g., honka in seriouscats domain) or service details (e.g., MuLiveUpdatingService).
    - **CQEvtxRecovery**:
        - **Purpose**: Recovers corrupted event logs.
        - **Note**: Use for damaged .evtx files exported from memory.
    - **Analysis Steps**:
        1. Check autostart keys with printkey or Registry Explorer.
        2. Use handles -t Key to identify registry keys accessed by suspicious processes.
        3. Analyze SAM for new user accounts in Registry Explorer.
        4. Export security.evtx and System.evtx using filescan and dumpfiles, analyze in Event Viewer.
        5. Check scheduled tasks in SOFTWARE with RegRipper (taskcache, tasks).
        6. Use svcscan or autoruns for service-based persistence.
    - **Important Notes**:
        - Suspicious service or task executables in temporary folders (e.g., C:\Users\AppData\Local\Temp) are red flags.
        - Domain user creation requires domain controller logs.
        - Corrupted event logs may require CQEvtxRecovery.
        - autoruns provides quick but limited persistence data; verify with manual registry checks.
    
    ## Creating Timelines
    
    ### Theoretical Concepts
    
    - **Goal**: Reconstruct system events, attacker actions, or user activity using timestamps from memory.
    - **Types**:
        - **Filesystem-Based Timelines**: Use filesystem metadata (e.g., $MFT) for file creation/modification timestamps.
        - **Memory-Based Timelines**: Include process creation, network connections, and registry changes.
    - **Applications**:
        - Analyze system changes during an incident.
        - Track file timestamps for malicious activity (e.g., prefetch files indicating program execution).
        - Identify malware execution via process creation or prefetch files.
    - **Prefetch Mechanism**:
        - Windows creates .pf files in C:\Windows\Prefetch during program startup, including executable names.
        - Creation of a prefetch file indicates program execution.
    
    ### Practical Steps and Tools
    
    - **Volatility Plugin: mftparser**:
        - **Purpose**: Extracts $MFT entries for filesystem-based timelines.
        - **Command**: .\volatility_2.6_win64_standalone.exe -f D:\nwe.mem --profile=Win7SP1x64 mftparser --output=body --output-file=D:\output\body.txt.
        - **Output**: Unsorted $MFT records (Figure 5.53).
    - **TheSleuthKit (mactime)**:
        - **Purpose**: Converts $MFT records into a timeline.
        - **Installation**:
            - Install Perl: https://strawberryperl.com/.
            - Download Windows Binaries: https://www.sleuthkit.org/sleuthkit/download.php.
        - **Command**: C:\Strawberry\perl\bin\perl.exe D:\sleuthkit-4.10.2-win32\bin\mactime.pl -b D:\output\body.txt > D:\output\timeline.txt.
        - **Output**: Timeline with file creation events (e.g., Gnh3J8f.EXE prefetch file; Figure 5.54).
    - **Volatility Plugin: timeliner**:
        - **Purpose**: Builds memory-based timeline with process, network, and registry events.
        - **Command**: .\volatility_2.6_win64_standalone.exe -f D:\nwe.mem --profile=Win7SP1x64 timeliner > D:\output\timeline.txt.
        - **Output**: Comprehensive event timeline (Figure 5.55).
    - **Redline**:
        - **Purpose**: Creates graphical timelines with customizable data sources.
        - **Steps**:
            1. Load memory dump.
            2. Select data sources (e.g., processes, network connections).
            3. View timeline (Figure 5.56).
    - **Analysis Steps**:
        1. Extract $MFT with mftparser, convert to timeline with mactime.
        2. Run timeliner for memory-based events, redirect to text file.
        3. Use Redline for graphical timeline analysis.
        4. Search for prefetch files (e.g., Gnh3J8f.EXE.pf) or suspicious process creation times.
    - **Important Notes**:
        - Prefetch files confirm program execution, critical for malware detection.
        - timeliner output is extensive; use text editors or Excel for analysis.
        - Redline’s graphical interface simplifies timeline navigation.
    
    ## Summary of Key Points
    
    - **Malware Detection**: Focuses on identifying rogue processes, network connections, code injections, and persistence mechanisms in memory dumps.
    - **Key Markers**:
        - Process anomalies: Misspelled names, non-standard parents, locations, or behaviors.
        - Command-line arguments: Reveal file paths, credentials, or encoded scripts.
        - Network connections: Atypical initiators, suspicious IPs/ports (e.g., Meterpreter on 4444).
        - Injections: DLLs, PE, hollowing, or doppelgänging, often in PAGE_EXECUTE_READWRITE regions.
        - Persistence: Autostart keys, new accounts, services, or scheduled tasks.
    - **Tools and Commands**:
        - **Volatility**: pslist, cmdline, cmdscan, consoles, yarascan, netscan, dllist, ldrmodules, dlldump, malfind, psinfo, volshell, cobaltstrikescan, printkey, handles, svcscan, autoruns, mftparser, timeliner.
        - **External Tools**: CyberChef (Base64 decoding), VirusTotal (IP/file analysis), CFF Explorer (code analysis), oletools (macro analysis), Registry Explorer/RegRipper (registry analysis), Event Viewer (event logs), CQEvtxRecovery (log recovery), TheSleuthKit (timeline creation), Redline (memory/timeline analysis).
    - **Practical Workflow**:
        1. Identify rogue processes with pslist, checking names and parents.
        2. Analyze arguments with cmdline, cmdscan, consoles, decoding scripts with CyberChef.
        3. Examine network connections with netscan, verifying IPs on VirusTotal.
        4. Detect injections with dllist, ldrmodules, malfind, psinfo, or volshell.
        5. Check persistence via printkey, handles, Registry Explorer, RegRipper, or event logs.
        6. Build timelines with mftparser, mactime, timeliner, or Redline.
    
    ## Notes for Digital Forensics Investigators
    
    - **Critical Tools and Paths**:
        - **Volatility 2.6**: Download from https://www.volatilityfoundation.org/26.
            - Process: .\volatility_2.6_win64_standalone.exe -f D:\nwe.mem --profile=Win7SP1x64 pslist.
            - Network: .\volatility_2.6_win64_standalone.exe -f D:\nwe.mem --profile=Win7SP1x64 netscan.
            - Injection: .\volatility_2.6_win64_standalone.exe -f D:\nwe.mem --profile=Win7SP1x64 malfind -p <PID> -D D:\output.
            - Persistence: .\volatility_2.6_win64_standalone.exe -f D:\nwe.mem --profile=Win7SP1x64 printkey -K "SOFTWARE\Microsoft\Windows\CurrentVersion\Run".
        - **oletools**: pip3.exe install -U oletools, run olevba D:\output\GOT-7_HR.docm.
        - **CyberChef**: https://gchq.github.io/CyberChef/ for Base64 decoding.
        - **VirusTotal**: https://www.virustotal.com/gui/home/search for IP/file checks.
        - **CFF Explorer**: https://ntcore.com/?page_id=388 for code analysis.
        - **Redline**: https://www.fireeye.com/services/freeware/redline.html for memory/timeline analysis.
        - **TheSleuthKit**: https://www.sleuthkit.org/sleuthkit/download.php, run mactime.pl -b D:\output\body.txt > D:\output\timeline.txt.
        - **Registry Explorer/RegRipper**: https://ericzimmerman.github.io/#!index.md, https://github.com/keydet89/RegRipper3.0.
        - **cobaltstrikescan**: https://github.com/JPCERTCC/aa-tools/blob/master/cobaltstrikescan.py, use with --plugins=./plugins.
    - **Sensitive Considerations**:
        - **Malicious Documents**: Macros in documents (e.g., GOT-7_HR.docm) can spawn processes like rundll32.exe or powershell.exe; analyze with olevba in a sandbox (Figure 5.6).
        - **Fileless Attacks**: Base64-encoded scripts in PowerShell or wscript.exe (e.g., PE files; Figure 5.42) require decoding and careful handling to avoid execution.
        - **Network Connections**: Suspicious IPs (e.g., 216.58.207.206) may not be flagged but have malicious file associations; always check VirusTotal’s RELATIONS tab (Figure 5.20).
        - **Injections**: Meterpreter, Cobalt Strike, or ransomware injections (e.g., SDBbot, Netwalker) are memory-resident; use malfind or cobaltstrikescan and verify extracted code on VirusTotal.
        - **Persistence**: New accounts (e.g., honka in seriouscats) or services in temporary folders (e.g., MuLiveUpdatingService) are high-priority for investigation.
        - **Timelines**: Prefetch files (e.g., Gnh3J8f.EXE.pf) confirm malware execution; combine filesystem and memory timelines for comprehensive analysis.
        - **Evidence Preservation**: Extracted files (e.g., DLLs, event logs) may be corrupted or malicious; use sandboxes and verify integrity before analysis.
        - **Community Plugins**: Ensure correct setup for cobaltstrikescan or autoruns to avoid errors.
        - **Event Log Recovery**: Use CQEvtxRecovery for corrupted .evtx files to recover critical user or service data.

---

This summary provides a detailed, standalone reference for conducting malware detection and analysis in Windows memory forensics, equipping investigators with the theoretical knowledge, practical steps, and precautions needed to effectively investigate malicious activity without referring to the original chapter.